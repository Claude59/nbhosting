# nbhosting.conf

# from Florian's implem
### map $http_upgrade $connection_upgrade {
###     default Upgrade;
###     ''      Close;
### }

# the upstream component nginx needs to connect to
upstream django {
    # a file socket to reach the upstream django app
    server unix:/run/nbhosting.sock; 
}

# configuration of the server
server {

    # the port your site will be served on
    listen 443 ssl;

    # the domain name it will serve for
    server_name nbhosting.inria.fr; 
    charset     utf-8;

    error_log    /var/log/nginx/daemon debug;
    rewrite_log on;

    ########## SSL config
    ssl_certificate /root/ssl-certificate/bundle.crt;
    ssl_certificate_key /root/ssl-certificate/nbhosting.inria.fr.key;
#
#    # Protect against the BEAST attack by preferring RC4-SHA when using SSLv3 and TLS protocols.
#    # Note that TLSv1.1 and TLSv1.2 are immune to the beast attack
#    # but only work with OpenSSL v1.0.1 and higher and has limited client support.
    ssl_protocols              TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers                HIGH:RC4:!EXPORT:!ADH:!MD5;
    ssl_prefer_server_ciphers  on;
#
#    # Optimize SSL by caching session parameters for 10 minutes.
#    # This cuts down on the number of expensive SSL handshakes.
#    # The handshake is the most CPU-intensive operation,
#    # and by default it is re-negotiated on every new/parallel connection.
#    # By enabling a cache (of type "shared between all Nginx workers"),
#    # we tell the client to re-use the already negotiated state.
#    # Further optimization can be achieved by raising keepalive_timeout,
#    # but that shouldn't be done unless you serve primarily HTTPS.
    ssl_session_cache    shared:SSL:10m; # a 1mb cache can hold about 4000 sessions,
#                                         # so we can hold about 40000 sessions
    ssl_session_timeout  10m;


# max upload size
    client_max_body_size 50M;   # adjust to taste


    # some static content for tests
    location / {
	root /var/lib/nginx/public_html/;
	index  index.html;
     }

    # the URLS that go to django
    location /ipythonExercice/ {
	uwsgi_pass  django;
	include     uwsgi_params; # the uwsgi_params file you installed
    }

    # edxfront.views.edx_request will redirect to a URL
    # that contains the actual port number as the element in the path
    # this needs to be reverse-proxi'ed to that docker/jupyter instance
    # for max. range we start at 2000
    location ~ ^/([2-9]\d\d\d|[1-9]\d\d\d\d)/(.*)$ {
	set $docker_port $1;
	set $notebook_path $2;
	allow all;

	# from florian's implem: We set a cookie in order to keep the port for api/ and static/
	add_header Set-Cookie "docker_port=$docker_port;Path=/;Max-Age=31536000";

	# use http & localhost here
	proxy_pass http://127.0.0.1:$docker_port/notebooks/$notebook_path$is_args$args;
	proxy_set_header Host $host;
#	proxy_buffering off;
#	proxy_read_timeout 300;
    }

    location ~ ^/(api|static|nbconvert|files|custom|login)(.*) {
	allow all;
	# we propagate the cookie we set earlier
	add_header Set-Cookie "docker_port=$cookie_docker_port;Path=/;Max-Age=31536000";

	# and we use it to find the local port where to proxy this
	proxy_pass http://127.0.0.1:$cookie_docker_port/$1$2$is_args$args;
	proxy_set_header Host $host;
###         proxy_set_header Upgrade $http_upgrade;
###         proxy_set_header Connection $connection_upgrade;
#	proxy_buffering off;
#	proxy_read_timeout 300;
#	proxy_http_version 1.1;
    }
}
