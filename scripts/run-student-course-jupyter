#!/bin/bash

# primarily does 3 things
#
# (*) check for existence of notebook in the student's space
# (*) make sure there is a notebook server ready and running for that couple student x course
# (*) return written on stdout as
#     docker-name docker-port jupyter-token
#
# if forcecopy is set to force, then the master notebook is always copied
# into the student's space, even if pre existing

COMMAND=$(basename $0)
USAGE="Usage: $COMMAND nbhosting-root student course notebook docker-image docker-port [force]"

[[ "$#" =~ [67] ]] || { echo $USAGE; exit 1; }

# from config - typically /nbhosting
root=$1; shift
# student name - should exist as /nbhosting/students/$student
student=$1; shift
# course name - should exist as /nbhosting/courses/$course
course=$1; shift
# notebook path - should exit as /nbhosting/courses/$course/$notebook
notebook=$1; shift
# docker image - should of course have jupyter inside
# there are some assumptions made about that image, first version of
# nbhosting was developped for jupyter/scipy-notebook, hopefully
# it could run with others some day
docker_image=$1; shift
# port number as provided by django
free_port=$1; shift
# if forcecopy is 'force', then the student's copy is overwritten
# from the course copy
forcecopy=$1; shift

########## constants
# xxx 
# we use the docker container name as the auth token
# this avoids the necessity to wait for the connection file to be readable
# which can take some time
# the name of a file where details on the running jupyter are exposed
# including the value for the auth token
# this change would be welcome but somehow it does not propagate
# down to the jupyter service that still creates nbserver-7.json
#connection_details="connection-details.json"
#connection_details="nbserver-7.json"

# set to any non-empty string to enable
debug=true

# all the verbosity goes to stderr as stdout is meant for the caller
function echo-stderr() {
    >&2 echo $(date "+%H:%M:%S") "$@"
}

function die() {
    echo-stderr "$@"
    exit 1
}

# globals
current_uid=$(id -un)

student_home=$root/students/$student
student_course=$student_home/$course
student_notebook=$student_course/$notebook
student_modules=$student_course/modules

#student_media=$student_course/media
#student_data=$student_course/data

course_nbroot=$root/courses/$course
course_notebook=$course_nbroot/$notebook
course_modules=$root/modules/$course

course_media=$root/static/$course/media
course_data=$root/static/$course/data

docker_name=${course}-x-${student}

log=$root/logs/$course/run-$student.log

# rain check
[ -d $student_home ] || die student dir not found $student_home
[ -d $course_nbroot ] || die course notebooks dir not found $course_nbroot
[ -f $course_notebook ] || die master notebook not found in course $course_notebook
# not enforced yet
#[ $current_uid == $student ] || echo-stderr WARNING should be run as uid $student
[ -d $course_modules ] || echo-stderr WARNING $course_modules dir not found
[ -d $course_media ] || echo-stderr WARNING $course_media dir not found
[ -d $course_data ] || echo-stderr WARNING $course_data dir not found

# tmp
for var in student_home course_nbroot course_notebook student_notebook; do
    [ -n "$debug" ] && echo-stderr $var = ${!var}
done

# create directory/ies leading to file <file>
function mkdir-for-file () {
    local filename=$1; shift
    local dir=$(dirname $filename)
    [ -d $dir ] || {
	echo-stderr Creating directory $dir for $filename
	sudo -u $student mkdir -p $dir
    }
}

# create symlink right where the notebook is, not only at the top
function create-symlink-at-file () {
    local filename=$1; shift
    local destination=$1; shift
    
    local dir=$(dirname $filename)
    local destname=$(basename $destination)
    # the symlink should
    # be in dir/ (like filename)
    # be named destname
    # and point at destination
    local source=$dir/$destname
    ln -sf $destination $dir/$destname
}

# make sure the student has a copy of the nodebook
function check-student-notebook() {
    # copy if student notebook is missing, or if force is requested
    if [ ! -f $student_notebook ] || [ "$forcecopy" == "force" ]; then
	mkdir-for-file $student_notebook
	echo-stderr Creating $student_notebook from $course_notebook 
	sudo -u $student cp $course_notebook $student_notebook
	create-symlink-at-file $student_notebook /home/jovyan/work/media
	create-symlink-at-file $student_notebook /home/jovyan/work/data
    else
	[ -n "$debug" ] && echo-stderr Student copy $student_notebook is fine
    fi
    # 
    # nothing else is required in the student's work area
    # the rest (modules, media, data) will be bind-mounted
    # in the docker container
    # 
}

# grep token /nbhosting-test/students/john/flotbioinfo/runtime/share/jupyter/runtime/nbserver-7.json
# "token": "205c97892d61ef1c8434ab6dddb1731182a8ae2fce8d2956",
# xxx unused for now
# function parse-token() {
#     student_runtime=$1; shift
#     # we reconfigure jupyter to use a specific filename for that details file
#     json_file=$student_runtime/share/jupyter/runtime/${connection_details}
#     # allow for a grace timeout before deciding it's hopeless
#     local seconds=3
#     local loops=$(($seconds * 10))
#     local i
#     for i in $(seq $loops); do
# 	if [ -f $json_file ]; then
# 	    break
# 	else
# 	    echo-stderr "$i-th attempt at token file $json_file .."
# 	    sleep .1
# 	fi
#     done
#     # still not there after 1s, bail out...
#     [ -f $json_file ] || { echo 0; return 1; }
#     
#     grep token $json_file | sed -e 's,", ,g' -e 's,:, ,g' | awk '{print $2;}'
# }

# retrieve port from output like this
# map[8888/tcp:[{ 57971}]]
function get-port-from-portbindings() {
    file=$1; shift
    cat $file | sed -e 's,[^0-9][^0-9]*, ,g' | cut -d' ' -f 3
}
		    

# we name the docker instance as <course>-x-<student>
# we have the ability to assign a port - that will be mapped into container's fixed 8888
function run-docker-instance() {
    [ -n "$debug" ] && set -x

    #  exit with retcode != 0 if anything goes south
    set -e
    
    local student_runtime=$student_course/runtime
    [ -d $student_runtime ] || {
	echo-stderr Creating runtime $student_runtime
	mkdir -p $student_runtime
	chown -R $student:$student $student_runtime
    }
    
# other options worth investigating
#	     --no-browser \
#	     --keyfile=xxx \
#	     --certfile=xxx \
#	     --pylab=xxx \
#	     --NotebookApp.token=<Unicode> \	     


    local jupyter_token=$docker_name
    local inspect_file=/tmp/$docker_name.port-bindings
    # check if container docker_name is already defined
    # beware we are in a set -e section
    docker inspect -f "{{.HostConfig.PortBindings}}" $docker_name > $inspect_file 2> /dev/null \
	&& { \
	     # this is the case where docker inspect was successful
	     # retrieve (actual) port number from inspect_file
	     docker_port=$(get-port-from-portbindings $inspect_file)
    } || { \
	   # this now is when docker inspect fails
	   echo-stderr Creating docker container $docker_name
	   # * map host free port to fixed 8888 in container
	   # * bind  mounts so that the user's data is on
	   #   the host filesystem
	   # * for turning off token auth, we would need to specify the command to run:
	   #    --NotebookApp.token=''
	   # * an attempt to access the runtime file for parsing auth token
	   # -v $student_runtime:/home/jovyan/.local 
	   command="sudo -u $student docker create --name $docker_name
	       -p $free_port:8888 
	       -v $student_course:/home/jovyan/work 
               -v $course_modules:/home/jovyan/modules 
	       -v $course_media:/home/jovyan/work/media 
	       -v $course_data:/home/jovyan/work/data 
	       -e PYTHONPATH="/home/jovyan/modules" 
	       $docker_image 
	       start-notebook.sh 
	       --NotebookApp.token=$jupyter_token 
	       --NotebookApp.open_browser=False 
	       --JupyterApp.answer_yes=True 
	       --log-level=DEBUG"
	   # show command for manual debugging
	   echo-stderr XXXXXXXXXX $command
	   # we need a clean stdout : redirect stdout to stderr 
	   >&2 $command
	       # to expose to the outside
	       docker_port=$free_port
    }

    # start container docker_name
    # prevent clobbering of stdout
    >&2 sudo -u $student docker start $docker_name 

    ### xxx local jupyter_token=$(parse-token $student_runtime)
    ###[ $jupyter_token == 0 ] && exit 1
    # this is the only thing that goes on stdout
    echo $docker_name $docker_port $jupyter_token

    [ -n "$debug" ] && set +x
}

function main() {
    check-student-notebook
    run-docker-instance
}

echo-stderr "========== $(date)"
# we always leave stdout alone as it's the outcome of this script
# but as far as stderr, we want to log it and to return it in stderr
main 2> >(tee $log >&2)

exit 0
